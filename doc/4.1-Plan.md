from src.mbrot_fractal import windowfrom src.image import draw_fractalfrom fileinput import filename

# CS 1440 Project 4.1: Software Development Plan

Phase 0: Requirements Analysis (tag name `4.1-analyzed`)
--------------------------------------------------------
*(20% of your effort)*

**Important - do not change the starter code in this phase.**  Feel free to write prototype files and experiment in the REPL, but it's too early to work on the starter code now.


Deliver:

*   [X] Re-write the instructions in your own words.
    *   With the program now refactored, I need to add 2 more fractal options, making the total amount of fractals that the program can draw up to 4. As well, I need to add 5 different color palettes to use that the user can select from
        *    I need to use Object-Oriented Programming (OOP) to implement the fractal equations to draw them and to make the 5 palettes.
        *    I need to make an abstract class for fractals and one for palettes called `Fractal` and `Palette` respectively.
        *    I need to rewrite the user manual so that it now describes how to use the new version of the program.
        *    I need to implement a `default` value for when the user does not include a `data/` file and/or a color palette.
        *    Implement the `factory_method` for when the palettes and fractals are instantiated.
*   [X] Explain the problem this program aims to solve.
    *   Describe what a *good* solution looks like.
        *   A good solution has 3 aspects:
             *   When the user does not provide a `data/` .frac file and/or a palette name, the program will use its hardcoded default values to draw a fractal
             *   When the user does include a `data/` .frac file and a color palette name, the program will print the progress bar of the image as it is drawn, an image window that shows the fractal being drawn, that it was saved when finished drawing, and the way to exit the program.
             *   The program is ran using the `main.py` file.
    *   List what you already know how to do.
        *    I know how to write classes
        *    I know how to apply class inheritance
        *    I know how to use the mandelbrot and phoenix algorithms
        *    I know how to use tkinter in a basic way
        *    I know how to read contents of a file and put them into a dictionary
        *    I know how to set default values for classes
    *   Point out any challenges that you can foresee.
        *    I don't know how to generate a color palette based off of 2 colors
        *    I don't know any other fractal algorithms
        *    I don't know how to do proper error handling with classes
*   [X] List all of the data that is used by the program, making note of where it comes from.
    *   The program uses 4 different data sources:
        *    A filename from the command line
        *    The information inside the file that was provided to the command line
        *    A name for a color palette
        *    The color palette created by one of the `Palette` subclasses to draw the fractal
*   [X] Explain what form the program's output will take.
    *   The programs output has 2 main parts:
        *    The command line will say that it is drawing the fractal with a progress bar. When the image has terminated, there will be total time taken to draw the fractal, that it was saved to a `.png` file, and how to exit out of the program
        *    While the command line has the progress bar show the progress of how much of the image is drawn, a tkinter window will open that will update along the progress bar, showing the image being drawn.
*   [X] **Tag** the last commit in this phase `4.1-analyzed` and push it to GitLab.
    *   *Grace Points: if this tag is pushed by 11:59 PM on the Monday before the due date, you will receive up to 5 points back*


Phase 1: Design (tag name `4.1-designed`)
-----------------------------------------
*(30% of your effort)*

**Important - do not change the starter code in this phase.**  Feel free to write prototype files and experiment in the REPL, but it's too early to work on the starter code now.

Deliver:

*   [ ] Pseudocode that captures how each function works in plain language.
    *   ```python
        fractal.py
        fractal abstract class
        class Fractal:
        
        __init__ method:
        input: 'frac' variable
        output: if called, raises error.
                returns nothing
        ===============
        def __init__(self, 'frac' variable):
            if the Fractal class is called, not a subclass:
                raise an NotImplemented error that says '"Fractal is an abstract class and must be extended'
    
        count method:
        a place holder function
        ===============
        def count(self, z):
            if 'Fractal.count' is called:
                raise a NotImplemented error that says 'Concrete subclass of Fractal must implement count()'
        
        min_max method:
        input: a fractal dictionary
        output: nothing is printed
                returns a 'minimum' array and 'size' variables
        ===============
        def min_max(frac_dict):
            set 'minimum' to ['frac_dict[centerx]' minus ('frac_dict[axislength]'/2)] and ['frac_dict[centery]' minus ('frac_dict[axislength]'/2)]
            set 'maximum' to 'frac_dict[centerx]' plus ('frac_dict[axislength]'/2)
            set 'size' to the absolute value of ('maximum' minus 'minimum'[0]) divided by 'frac_dict[pixels]'
            return 'minimum' and 'size'
        
        mandelbrot.py
        from fractal.py import Fractal
        class Mandelbrot(Fractal):
        
        __init__ method:
        input: a dictionary made from the parser method
        output: if called, raises error.
                returns nothing
        ===============
        def __init__(self, 'frac_dict' a dictionary):
            try:
                set 'self.iterations' as 'frac_dict["iterations"]' converted to an integer
            catch:
                raise a RuntimeError that tells the user which property is incorrect or misspelled
        
        count method:
        input: uses variables that were intitalized from 'frac_dict', and a complex number 'c'
        output: nothing
                returns an iteration number
        ===============
        def count(c):
            create a variable 'z' that is set to the complex number of (0,0)
            for the iteration in 'self.iterations':
                set 'z' to ('z' times 'z') plus 'c'
                if the absolute value of 'z' is greater than 2:
                    return the current iteration count
            return 'self.iterations' if 'z' is never greater than 2
        
        phoenix.py
        from fractal.py import Fractal
        class Phoenix(Fractal):
        
        __init__ method:
        input: a dictionary made from the parser method
        output: if called, raises error.
                returns nothing
        ===============
        def __init__(self, 'frac_dict' a dictionary):
            try:
                set 'self.iterations' as 'frac_dict["iterations"]' converted to an integer
                set 'self.creal' as 'frac_dict["creal"]' converted to a float number
                set 'self.cimag' as 'frac_dict["cimag"]' converted to a float number
                set 'self.preal' as 'frac_dict["preal"]' converted to a float number
                set 'self.pimag' as 'frac_dict["pimag"]' converted to a float number
            catch:
                raise a RuntimeError that tells the user which property is incorrect or misspelled
        
        count method:
        input: uses variables that were intitalized from 'frac_dict', and a complex number 'z'
        output: nothing
                returns an iteration number
        ===============
        def count(z):
            create a variable 'z_prev' that is set to the complex number of (0,0)
            for the iteration in 'self.iterations':
                'z_save' is the current 'z' value
                set 'z' to (('z' times 'z') plus the complex number of 'self.creal' and 'self.cimag') plus (the complex number of 'self.preal' and 'self.pimag' timesd by 'z_prev')
                set 'z_prev' to 'z_save'
                if the absolute value of 'z' is greater than 2:
                    return the current iteration count
            return 'self.iterations' if 'z' is never greater than 2

        dragon.py
        from fractal.py import Fractal
        class Dragon(Fractal):
        
        __init__ method:
        input: a dictionary made from the parser method
        output: if called, raises error.
                returns nothing
        ===============
        def __init__(self, 'frac_dict' a dictionary):
            try:
                set 'self.iterations' as 'frac_dict["iterations"]' converted to an integer
            catch:
                raise a RuntimeError that tells the user which property is incorrect or misspelled
        
        count method:
        input: uses variables that were intitalized from 'frac_dict'
        output: nothing
                returns an iteration number
        ===============
        def count(c):
            create a variable 'z' that is set to the complex number of (0,0)
            for the iteration in 'self.iterations':
                set 'z' to ('z' to the 3rd power divided by ('z' to the 3rd power plus 1)) plus 'c'
                if the absolute value of 'z' is greater than 2:
                    return the current iteration count
            return 'self.iterations' if 'z' is never greater than 2
        
        lambda.py
        from fractal.py import Fractal
        class Lambda(Fractal):
        
        __init__ method:
        input: a dictionary made from the parser method
        output: if called, raises error.
                returns nothing
        ===============
        def __init__(self, 'frac_dict' a dictionary):
            try:
                set 'self.iterations' as 'frac_dict["iterations"]' converted to an integer
            catch:
                raise a RuntimeError that tells the user which property is incorrect or misspelled
        
        count method:
        input: uses variables that were intitalized from 'frac_dict', and a complex number 'z'
        output: nothing
                returns an iteration number
        ===============
        def count(z):
            for the iteration in 'self.iterations':
                set 'z' to (-(0.85 + 0.6i) times by 'z') times (1-'z')
                if the absolute value of 'z' is greater than 2:
                    return the current iteration count
            return 'self.iterations' if 'z' is never greater than 2
        
        parser.py
        parser function:
        input: a filename
        output: nothing is printed
                returns a dictionary with all the info from the '.frac' file
        ===============
        def parser(filename):
            f = open(filename)
            create a new dictionary called 'frac_dict'
            set 'name' in the 'frac_dict' to the stem of 'filename'
            for line in f:
                set 'line_frmted' to 'line' rstripped and lowered
                if 'line_frmted' starts with a '#' or is a blank line:
                    continue to the next line
                create the pair by using '.replace(" ", "").split(:)' and set it to 'dict_pair'
                if the length of 'dict_pair' is not equal to 2:
                    close 'f'
                    raise a RuntimeError that says f'Parse error at line #{ln_num} of {filename}: wrong number of tokens\n {line}'
                else:
                    set 'frac_dict'['dict_pair[0]'] to the value of 'dict_pair[1]'
            close 'f'
            return 'frac_dict'

        fractalfactory.py 
        from parser.py import parser
        from lambda.py import Lambda
        from dragon.py import Dragon
        from mandelbrot.py import Mandelbrot
        from phoenix.py import Phoenix
        
        
        class FractalFactory:
            __init__ method:
            input: a dictionary made from the parser method
            output: if called, raises error.
                    returns nothing
            ===============
            def __init__(self, filename):
                'self.frac_dict' = 'filename' passed to 'parser()'
            
            make method:
            input: a type of fractal
            output: makes the fractal image/inforamtion
                    returns a dictionary of a fractal
            ===============
            def make(self, dictionary):
                if 'self.frac_dict[type]' is 'mandelbrot':
                    return 'Mandelbrot(frac_dict)'
                elif 'self.frac_dict[type]' is 'phoenix':
                    return 'Phoenix(frac_dict)'
                elif 'self.frac_dict[type]' is 'dragon':
                    return 'Dragon(frac_dict)'
                elif 'self.frac_dict[type]' is 'lambda':
                    return 'Lambda(frac_dict)'
        
        image.py
        from tkinter import Tk, Canvas, PhotoImage, mainloop
        from time import time
        
        class ImagePainter()
            __init__ method:
            input: a object from 'fractalfactory.py' and 'palettefactory.py'
            output: creates variables to use through out object
                    returns nothing
            ===============
            def __init__(self, frac, pal):
                'self.frac' = frac
                'self.pal' = pal
            
            create_window method:
            input: nothing
            output: nothing
                    returns a window object, image object, and that start time of the fractal
            ===============
            def create_window():
                set 'bg_color' to '#000000'
                set 'start_time' to 'time()'
                set 'window' to a tkinter obejct 'Tk()'
                set 'canvas' to the 'Canvas' object, with 'width' and 'height' set as 'frac[pixels]' and 'background' to 'bg_color'
                pack 'canvas'
                set img to a 'PhotoImage' object with the 'width' and 'height' as 'frac[pixels]'
                on 'canvas' call 'create_image' with the first argument as ('frac[pixels]'/2, 'frac[pixels]'/2), then 'image' as 'img' and 'state' as 'normal'
                return 'window', 'img', and 'start_time'
            
            draw_fractal method:
            input: fractal dict, palette array, a window and image objects
            output: prints the fractal image/draws it into the tkinter window
                    returns nothing
            ===============
            def draw_fractal(frac, pal, window, img):
                set 'minimum' and 'size' to 'frac.min_max'
                for every row in the range('frac[pixels]', 0, -1):
                    create 'clr_array' that is empty array
                    set 'y' as 'minimum'[1] plus ('row' times 'size')
                    for every 'col' in the range('frac[pixels]'):
                        set 'x' to 'minimum'[0] plus ('col' times 'size')
                        append to 'clr_array' the color returned by (pal[frac.count(the complex number of 'x', 'y')])
                    put 'clr_array' in 'img', using 'frac[pixels]' minus 'row' to dictate which row to put the array on
                    update 'window'
                    print the status bar progess
                call the mainloop function
                
        
            status_bar method:
            input: a int row number
            output: nothing is printed
                    returns a status bar and the progrss of the fractal
            ===============
            def status_bar(row):
                setr 'progress' to 'frac[pixels]' minus 'row' then divided by 'frac[pixels]'
                return a string that has 'progress' formatted and '=' printed according to the progress of the image
            
            draw_time method:
            input: a fractal dict, a img object and time variable
            output: prints the total time taken to draw fractal and how to exit out of the program
                    returns nothing
            ===============
            def draw_time(frac, img, start_time):
                write the fractal image to 'img'
                print a statement that says how long it took to draw the image
                print a statement that says the image was saved
                print a statement that says how to quit the program
        
        palette.py
        palette abstract class
        class Palette:
        
        __init__ method:
        input: 'num_colors' variable
        output: if called, raises error.
                returns nothing
        ===============
            def __init__(self, 'num_colors' variable):
                if the Palette class is called, not a subclass:
                    raise an NotImplemented error that says 'Palette is an abstract class and must be extended'
                set 'self.num_colors' as the 'num_colors' variable
            
        get_colors method:
        a place holder function
        ===============
            def get_colors(self, 'n' variable):
                raise a NotImplemented error if 'Palette.get_color' is called
        
        __len__ method:
        returns the length of the 'num_colors' variable
        ===============
        def __len__(self):
            return 'self.num_colors'
        
        toxic.py
        from colour import Color
        from palette import Palette
        class Toxic(Palette):
        
        __init__ method:
        input: 'start', 'mid', and 'end' variables
        output: if called, raises error.
                returns nothing
        ===============
            def __init__(self, n):
                set 'self.start' to Color('#00ff00')
                set 'self.mid' to Color('#151515')
                set 'self.end' to Color('#00ff04')
                set 'self.n' to 'n'
        
        get_colors method:
        input: a int that indicates number of colors to be made
        output: this prints nothing
                returns a color list
        ===============
            def get_colors(self, 'n' variable):
                create an empty list called 'pal'
                for color in th list of 'self.start'.range_to ('self.mid', and n/2):
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                for color in th list of 'self.mid'.range_to ('self.end', and n/2)[1:]:
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                return 'pal'
               
        murica.py
        from colour import Color
        from palette import Palette
        class Murica(Palette):
        
        __init__ method:
        input: 'start', 'mid', and 'end' variables
        output: if called, raises error.
                returns nothing
        ===============
            def __init__(self, n):
                set 'self.start' to Color('#FF0000')
                set 'self.mid' to Color('#FFFFFF')
                set 'self.end' to Color('#0000FF')
                set 'self.n' to 'n'
        
        get_colors method:
        input: a int that indicates number of colors to be made
        output: this prints nothing
                returns a color list
        ===============
            def get_colors(self, 'n' variable):
                create an empty list called 'pal'
                for color in th list of 'self.start'.range_to ('self.mid', and n/2):
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                for color in th list of 'self.mid'.range_to ('self.end', and n/2)[1:]:
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                return 'pal'
        
        joker.py
        from colour import Color
        from palette import Palette
        class Joker(Palette):
        
        __init__ method:
        input: 'start', 'mid', and 'end' variables
        output: if called, raises error.
                returns nothing
        ===============
            def __init__(self, n):
                set 'self.start' to Color('#32CD32')
                set 'self.mid' to Color('#FFFFFF')
                set 'self.end' to Color('#800080')
                set 'self.n' to 'n'
        
        get_colors method:
        input: a int that indicates number of colors to be made
        output: this prints nothing
                returns a color list
        ===============
            def get_colors(self, 'n' variable):
                create an empty list called 'pal'
                for color in th list of 'self.start'.range_to ('self.mid', and n/2):
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                for color in th list of 'self.mid'.range_to ('self.end', and n/2)[1:]:
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                return 'pal'
        
        oceandepth.py
        from colour import Color
        from palette import Palette
        class OceanDepth(Palette):
        
        __init__ method:
        input: 'start', 'mid', and 'end' variables
        output: if called, raises error.
                returns nothing
        ===============
            def __init__(self, n):
                set 'self.start' to Color('#1A5276')
                set 'self.mid' to Color('#5DADE2')
                set 'self.end' to Color('#F7DC6F')
                set 'self.n' to 'n'
        
        get_colors method:
        input: a int that indicates number of colors to be made
        output: this prints nothing
                returns a color list
        ===============
            def get_colors(self, 'n' variable):
                create an empty list called 'pal'
                for color in th list of 'self.start'.range_to ('self.mid', and n/2):
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                for color in th list of 'self.mid'.range_to ('self.end', and n/2)[1:]:
                    append 'color' to 'pal' and use '.hex_l' no make sure it can be read as a hexadecimal number
                return 'pal'
        
        palettefactory.py
        from toxic import Toxic
        from murica import Murica
        from joker import Joker
        from oceandepth import OceanDepth
        
        class PaletteFactory:
        __init__ method:
        input: 'num_colors' variable
        output: if called, raises error.
                returns nothing
        ===============
            def __init__(self):
        
        make function:
        input: 'num_colors' as an int and 'name' as a str
        output: prints nothing
                returns a list of colors
        ===============
        def make(self, num_colors, name='toxic'):
            if name is 'toxic':
                return Toxic.get_colors('num_colors')
            elif name is 'murica':
                return Murica.get_colors('num_colors')
            elif name is 'joker':
                return Joker.get_colors('num_colors')
            elif name is 'oceandepth':
                return OceanDepth.get_colors('num_colors')

        ```
    *   Describe important functions and classes in your program.  Include such details as:
        *   Names of functions/classes
        *   Parameter names and their types
        *   Types of data returned by functions
*   [X] Explain what happens in the face of good and bad input.
    *   In the face of good input:
        *   The program will print to the command line a progress bar
        *   The program will print to the command line a line that stays the image was saved
        *   The program will print to the command line instructions on how to exit the program
        *   A window will appear, drawing the fractal image in real time
    *   In the face of bad input:
        *   The program will crash if the file doesn't exist
        *   The program will raise an error if the color palette name given doesn't exist
        *   If nothing is provided, the program will use the default values.
*   [X] **Tag** the last commit in this phase `4.1-designed` and push it to GitLab.
    *   *Grace Points: if this tag is pushed before class on the Monday before the due date, you will receive up to 5 points back*


Phase 2: Implementation (tag name `4.1-implemented`)
----------------------------------------------------
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [X] Working code in the `src/` folder.
*   [X] Note any relevant and interesting events that happened while you wrote the code.
    *   The way that I accessed different properties of the fractal dictionaries was incorrect, I needed to make the right variables with the right type of numbers to use in other parts of the drawing process
    *   The program didn't like `[1:]` when trying to create the color palettes
    *   Figuring out what types of information that was needed to make the fractal image for each type of fractal needs to be done within the fractals class.
    *   Creating the `default` parameters was interesting, especially for the palette. I settled on the program seeing if anything was passed for the `palette` keyword, if not, it calls the `toxic` palette
*   [X] **Tag** the last commit in this phase `4.1-implemented` and push it to GitLab.


Phase 3: Testing and Debugging (tag name `4.1-tested`)
------------------------------------------------------
*(30% of your effort)*

Your grade depends on how your program performs when run from the command line.  We don't use PyCharm to grade, so ensure your program runs correctly from the shell.

Deliver:

*   [X] A set of test cases that you have personally run on your computer.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.
        *    Run `python src/main.py` without any arguments for the fractal file and for the palette - it will create the following image and output to the command line:
             *    ```bash
                  python src/main.py
                  fractal_factory: creating default fractal
                  palette_factory: creating default color palette
                  Rendering default fractal
                  [100% =================================]
                  Done in 8.501 seconds!
                  Saved image to file default.png
                  Close the image window to exit the program
                  ``` 
             * [default.png](/default.png) 
        *    Run `python src/main.py` with `data/lambda.frac` - it will create the following image and output on the command line:
             *    ```bash
                  python src/main.py data/lambda.frac
                  palette_factory: creating default color palette
                  Rendering lambda fractal
                  [100% =================================]
                  Done in 3.335 seconds!
                  Saved image to file lambda.png
                  Close the image window to exit the program
                  ``` 
             * [lambda.png](/lambda.png)
        *    Run `python src/main.py` with `data/septagon.frac` and `oceanlava` - it will create the following image and output on the command line:
             *    ```bash
                  python src/main.py data/septagon.frac oceanlava
                  Rendering septagon fractal
                  [100% =================================]
                  Done in 11.154 seconds!
                  Saved image to file septagon.png
                  Close the image window to exit the program
                  ``` 
             * [Septagon.png](/septagon.png)
        *    Run `src/main.py` with `data/DNE` - the program will crash and display an error message about not being able to open the file:
             *    ```bash
                  python src/main.py data/DNE
                  Traceback (most recent call last):
                    File "C:\Users\Macro\cs1440-proj4\src\main.py", line 14, in <module>
                      frac = FractalFactory(sys.argv[1]).make()
                             ~~~~~~~~~~~~~~^^^^^^^^^^^^^
                    File "C:\Users\Macro\cs1440-proj4\src\fractalfactory.py", line 10, in __init__
                      self.frac_dict = parser(filename)
                                       ~~~~~~^^^^^^^^^^
                    File "C:\Users\Macro\cs1440-proj4\src\parser.py", line 4, in parser
                      f = open(filename)
                  FileNotFoundError: [Errno 2] No such file or directory: 'data/DNE'
                  ``` 
        *    Run `src/main.py` with `default` and `rain` as the palette - the program will display an error message that says the palette is not compatible:
             *   ```bash
                 python src/main.py default rain
                 fractal_factory: creating default fractal
                 Traceback (most recent call last):
                   File "C:\Users\Macro\cs1440-proj4\src\main.py", line 10, in <module>
                     pal = PaletteFactory().make(frac.iterations, sys.argv[2].lower())
                   File "C:\Users\Macro\cs1440-proj4\src\palettefactory.py", line 23, in make
                     raise NotImplementedError(f'{name} is not a supported palette')
                 NotImplementedError: rain is not a supported palette
                 ``` 
        *    Run `src/main.py` with `data/phoenix` and `rain` as the palette - the program will display an error message that says the palette is not compatible:
             *   ```bash
                 python src/main.py data/phoenix.frac rain
                 Traceback (most recent call last):
                   File "C:\Users\Macro\cs1440-proj4\src\main.py", line 10, in <module>
                     pal = PaletteFactory().make(frac.iterations, sys.argv[2].lower())
                   File "C:\Users\Macro\cs1440-proj4\src\palettefactory.py", line 23, in make
                     raise NotImplementedError(f'{name} is not a supported palette')
                 NotImplementedError: rain is not a supported palette
                 ```
    *   For any bugs discovered, describe their cause and remedy.
        *    I tried making a triple dragon fractal, but it makes lines in place of the look at numbers like how the mandelbrot or phoenix fractals form
        *    I made the log spiral fractal, but as I got closer to it the `cmath` `log` couldn't make the correct calculations, thus making it almost impossible to look at.
        *    Turns out that the number made by `abs(maximum - minimum[0]` divided by `pixels` is just the `axislength`
        *    To clean up the `__init__` method in each subclass of `Palette` and `Fractal`, I moved the conversion process of variables and the creation of the palette to a method. I then call that method in the `__init__`  method of the class.
        *    For the `Palette` subclasses, they weren't creating a long enough palette. I saw how long of a palette was being made, and increased the total by multiplying it by a number until it was just over the required length to draw the fractal.
*   [X] **Tag** the last commit in this phase `4.1-tested` and push it to GitLab.


Phase 4: Deployment (tag name `4.1-deployed`)
---------------------------------------------
*(5% of your effort)*

Deliver:

*   [X] **Tag** the last commit in this phase `4.1-deployed` and push it to GitLab.
*   [X] Your repository is pushed to GitLab.
*   [X] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Look for all of the tags in the **Tags** tab.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [X] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


Phase 5: Maintenance
--------------------

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [X] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   I think I could have written the error handling of the fractal subclasses better 
        *   Are there parts of your program which you aren't quite sure how/why they work?
            *    I'm a little unsure on how tkinter works.
            *    I am confused on why I needed to check if `z` is ever 0 so that `septagon` doesn't crash when dividing by 0.
        *   If a bug is reported in a few months, how long would it take you to find the cause?
            *    I think it would take less than an hour to narrow down the bug and fix it. 
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
            *    Yes, I wrote it so that anyone can understand my design choices and what my solution was to the problem presented by the project.
        *   ...yourself in six month's time?
            *    Yes, I wrote it so that I and anyone can understand my thought process and build on it if needed. 
    *   How easy will it be to add a new feature to this program in a year?
        *   Easy, with using abstract classes, it'll be easy to add new palettes and fractals to the project in general. 
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
            *    Yes, it will go faster, especially with more RAM, a better CPU, and more storage. 
        *   ...the operating system?
            *    Yes, I run the program from bash, and it runs perfectly, thus it should run from any other OS that has a command shell. 
        *   ...to the next version of Python?
            *    Yes, all the modules and methods utilized will not be affected a new version of python due to their simplistic nature, unless they make them more simple and concise, then it will affect it.... sadly :(
*   [X] Make one final commit and push your **completed** Software Development Plan to GitLab.
*   [X] Respond to the **Project Reflection Survey** on Canvas.
