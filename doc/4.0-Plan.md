from demo.interactive import windowfrom os import terminal_sizefrom wsgiref.validate import bad_header_value_refrom demo.interactive import windowfrom demo.interactive import windowfrom demo.interactive import windowfrom fileinput import filenamefrom src.test import phoenix_dictfrom demo.interactive import windowfrom fileinput import filenamefrom itertools import countfrom itertools import count

# CS 1440 Project 4.0: Software Development Plan

Phase 0: Requirements Analysis (tag name `4.0-analyzed`)
--------------------------------------------------------
*(20% of your effort)*

**Important - do not change the starter code in this phase.**  Feel free to write prototype files and experiment in the REPL, but it's too early to work on the starter code now.


Deliver:

*   [X] Re-write the instructions in your own words.
    *   The code provided works as intended. However, I need to refactor this code without having it affect how the user sees the fractal image. It should look the same for the user, but different for those who look at the code.
        *   I will need to write a user manual that explains how to use the program without explaining how the code on the back end works.
        *   I will also need to write a file that lists at least 10 different bad `smells` (something that may indicate a possible problem with the code) from the provided starter code.
*   [X] Explain the problem this program aims to solve.
    *   A good solution has 2 good outputs:
        *   When a file that starts with `m-` or `mandelbrot` from `data/` is used with `src/mbrot_fractal`, it produces the same output image as the example output image
        *   When a file that starts with `p-` or `phoenix` from `data/` is used with `src/phoenix_fractal`, it produces the same output image as the example output image
    *   List what you already know how to do.
        *   I know how to identify non-useful comments and remove the unneeded information in them
        *   I know how to recognize dead code and figure out how to remove it safely
        *   I know how to divide the functions into modules that correspond with their purpose
    *   Point out any challenges that you can foresee.
        *   A challenge will be to understand how the developer implemented the tkinter module
        *   A challenge will be trying to follow the developer's chain of thought as they wrote the code
        *   A challenge will be simplifying/getting rid of excess code from the functions written
        *   A challenge will be figuring out how to split functions into more concise functions
*   [X] List all of the data that is used by the program, making note of where it comes from.
    *   The program uses the filename from `data/` provided on the command line
    *   The program accesses the file provided and uses its information to make the fractal image
*   [X] Explain what form the program's output will take.
    *   The programs output will create a tkinter window showing a drawing from the algorithm and `data/` file provided
    *   The image created in the output will be saved to a png file. If the image already exists, the old one will be overwritten with the new one
    *   The output on the command line will show a progress bar for when the image is being written and instructions that tell the user how to exit the program when the image is done
*   [Xana] **Tag** the last commit in this phase `4.0-analyzed` and push it to GitLab.
    *   *Grace Points: if this tag is pushed by 11:59 PM on the Monday before the due date, you will receive up to 5 points back*


Phase 1: Design (tag name `4.0-designed`)
-----------------------------------------
*(30% of your effort)*

**Important - do not change the starter code in this phase.**  Feel free to write prototype files and experiment in the REPL, but it's too early to work on the starter code now.

Deliver:

*   [ ] Pseudocode that captures how each function works in plain language.
    *   Pseudocode != Python.  Do not paste your finished source code into this part of the plan.
    *   ```python
        parser.py
        import sys
        import pathlib
        class Parser:
            intitalize variables
            def __init__(self):
                create a 'self.' variable for 'filename'
                create a 'self.' variable for 'name' by using pathlib.Path('filename').stem
                create a 'self.' variable for 'ln_num' and set it to 1
                
        phoenix_dictionary function
        input: A filename
        output: nothing is printed to the terminal or tkinter window
                returns a dictionary with all the phoenix algorithm information
        ============
        def phoenix_dictionary():
            f = open 'self.filename'
            phoenix_dict = a new dict object
            phoenix_dict['name'] is 'self.name'
            for line in f:
                line_formatted = line rstriped of '\n' and lowered cased
                if line_formatted startswith '#' or == ''
                    skip it and continue
                dict_pair = " " in line_formatted replaced with "" and splitted at ":"
                if length of dict_pair is not equal to 2:
                    raise a runtime error stating f'Parse error at line #{'self.ln_num'} of {f}: wrong number of tokens\n {line}' 
                if dict_pair[0] is 'type' and dict_pair[1] is not 'phoneix':
                    print an error message 'f"{RED}Warning! incompatible fractal type detected: '{dict_pair[1]}'{RST}", file=sys.stderr'
                if dict_pair[0] is "type":
                    phoenix_dict['type'] = dict_pair[1]
                elif dict_pair[0] is "iterations" or 'pixels':
                    phoenix_dict[dict_pair[0]] = dict_pair[1] as an int
                elif dict_pair[0] is 'axislength' or 'centerx' or 'centery' or 'creal' or 'cimag' or 'preal' or 'pimag':
                    phoenix_dict[dict_pair[0]] = dict_pair[1] as a float
                add 1 to 'self.ln_num'
            close f
            if 'axislength', 'type', 'name', 'pixels', 'centerx', 'centerx', 'creal', 'cimag', 'preal', 'pimag' are not in phoenix_dict:
                raise a runtime error that says 'A required parameter is missing'
            return phoenix_dict
        
        mbrot_dictionary function:
        input: a filename
        output: nothing is printed to the terminal or tkinter window
                returns a dictionary with all the mandelbrot algorithm info
        ============
        def mbrot_dictionary():
            f = open 'self.filename'
            mbrot_dict = a new dict object
            mbrot_dict['name'] is 'self.name'
            for line in f:
                line_formatted = line rstriped of '\n' and lowered cased
                if line_formatted startswith '#' or == ''
                    skip it and continue
                dict_pair = " " in line_formatted replaced with "" and splitted at ":"
                if dict_pair is not equal to 2:
                    raise a runtime error stating f'Parse error at line #{'self.ln_num'} of {f}: wrong number of tokens\n {line}' 
                if dict_pair[0] is 'type' and dict_pair[1] is not 'mandelbrot':
                    print an error message 'f"{RED}Warning! incompatible fractal type detected: '{dict_pair[1]}'{RST}", file=sys.stderr'
                if dict_pair[0] is "type":
                    phoenix_dict['type'] = dict_pair[1]
                elif dict_pair[0] is "iterations" or 'pixels':
                    phoenix_dict[dict_pair[0]] = dict_pair[1] as an int
                elif dict_pair[0] is 'axislength' or 'centerx' or 'centery':
                    phoenix_dict[dict_pair[0]] = dict_pair[1] as a float
                add 1 to 'self.ln_num'
            close f
            if 'axislength', 'type', 'name', 'pixels', 'centerx', 'centerx' are not in mbrot_dict:
                raise a runtime error that says 'A required parameter is missing'
            return mbrot_dict
                    
        palette.py
        Create a class called Palettes that holds the mandelbrot and phoenix color palettes
        Class Palette:
            create the intializer function
            def __int__(self):
               set 'self.phoenix_palette' as ['#ffe4b5', '#ffe5b2', '#ffe7af', '#ffe8ac', '#ffeaa8', '#ffeca5',
            '#ffeea2', '#fff09f', '#fff39c', '#fff699', '#fff996', '#fffc92',
            '#ffff8f', '#fbff8c', '#f8ff89', '#f4ff86', '#f0ff83', '#ebff80',
            '#e7ff7d', '#e2ff79', '#deff76', '#d8ff73', '#d3ff70', '#ceff6d',
            '#c8ff6a', '#c2ff67', '#bcff63', '#b6ff60', '#b0ff5d', '#a9ff5a',
            '#a3ff57', '#9cff54', '#94ff51', '#8dff4d', '#86ff4a', '#7eff47',
            '#76ff44', '#6eff41', '#66ff3e', '#5dff3b', '#54ff37', '#4cff34',
            '#43ff31', '#39ff2e', '#30ff2b', '#28ff29', '#25ff2d', '#21ff31',
            '#1eff34', '#1bff39', '#18ff3d', '#15ff41', '#12ff46', '#0fff4b',
            '#0cff50', '#08ff55', '#05ff5b', '#02ff60', '#00fe66', '#00fb6d',
            '#00f873', '#00f579', '#00f17f', '#00ee84', '#00eb8a', '#00e88f',
            '#00e594', '#00e299', '#00df9e', '#00dba2', '#00d8a6', '#00d5aa',
            '#00d2ae', '#00cfb2', '#00ccb6', '#00c9b9', '#00c5bc', '#00c2bf',
            '#00bdbf', '#00b4bc', '#00abb9', '#00a3b6', '#009bb3', '#0092af',
            '#008bac', '#0083a9', '#007ba6', '#0074a3', '#006da0', '#00669d',
            '#005f9a', '#005996', '#005293', '#004c90', '#00468d', '#00418a',
            '#003b87', '#003684', '#003080', '#002b7d', '#00277a', '#002277']
            plus 2 black pixels '#FFFFFF'
        
            set 'self.mbrot_palette' as ['#E1D89F', '#E0DA9E', '#E0DC9C', '#DFDE9B', '#DEDF9A', '#DBDE98',
           '#D8DE97', '#D4DD96', '#D1DD94', '#CDDC93', '#CADC92', '#C6DB91',
           '#C3DB8F', '#BFDA8E', '#BCD98D', '#B8D98B', '#B4D88A', '#B0D889',
           '#ACD788', '#A8D786','#A4D685','#A0D684', '#9CD582', '#98D481',
           '#94D480', '#8FD37F', '#8BD37D', '#87D27C', '#82D17B', '#7ED17A',
           '#79D078', '#77D07A', '#76CF7C', '#75CF7E', '#73CE80', '#72CD83',
           '#71CD85', '#70CC87', '#6ECB8A', '#6DCB8C', '#6CCA8F', '#6BCA91',
           '#69C994', '#68C896', '#67C899', '#66C79C', '#65C79F', '#63C6A2',
           '#62C5A4', '#61C5A7', '#60C4AA', '#5FC3AD', '#5DC3B0', '#5CC2B3',
           '#5BC1B7', '#5AC1BA', '#59C0BD', '#57BFBF', '#56BABF', '#55B5BE',
           '#54B1BD', '#53ACBD', '#51A7BC', '#50A3BB', '#4F9EBB', '#4E99BA',
           '#4D94B9', '#4C8FB9', '#4A8AB8', '#4985B7', '#4880B7', '#487BB5',
           '#4876B4', '#4771B2','#476CB1','#4668AF','#4663AE', '#465EAC',
           '#455AAB', '#4556A9', '#4551A8', '#444DA6', '#4449A5', '#4345A3',
           '#4543A2', '#4843A1', '#4B429F', '#4E429E', '#51419C',
           '#54419B', '#574199', '#594098', '#5C4096', '#5E3F95', '#613F94',
           '#633F92', '#653E91', '#673E8F', '#6A3D8E', '#6C3D8C', '#6D3C8B',
           '#6F3C8A', '#713C88', '#733B87', '#753B85', '#763A84', '#783A83',
           '#793981', '#7A3980', '#7C387E', '#7D387D']

        mandelbrot.py
        Class Mandelbrot:
    
        count function:
        input: a complex number and int iteration count
        output: converts a coordinate into an iteration count
                returns an int iteration number
        ============
        def count(self, c, max_iterations):
            create a complex number with (0,0) and assign it to 'z' to represent z0
            for each 'iteration' in the range of 'max_iteration':
                'z' = 'z' times it self plus 'c'
                if the abolute value of 'z' is greater than 2:
                    return 'iteration'
            return 'max_iterations' if 2 is never reached
            
        phoenix.py
        Class Phoenix
        
        count function:
        input: 'z' and 'c' as complex numbers, int iteration count, and the complex number phoenix fractacl constant
        output: prints nothing to terminal and tkinter window
                returns a int iteration number 
        ============
        def count(z, max_iterations, c, phoenix):
            make a 'z_previous' variable to hold the 'z' value from the last iteration and assign complex(0,0) to it
            for 'iteration' in range of 'max_iterations':
                create a int variable 'z_save' that holds the current 'z' value
                'z' = 'z' times itself plue 'c' and times by product of 'phoenix' and 'z_previous'
                'z_previous' = 'z_save'
                if the absolute value of 'z' is greater than 2:
                    return 'iteration'
            return 'max_iteration' if 'z' never exceeds 2
        
        image.py
        from palettes import Palette
        import mandelbrot
        import phoenix
        from tkinter import Tk, Canvas, PhotoImage, mainloop
        from time import time
        import sys
        
        Class Image:
            create initalizer function
            def __init__(self, dict, pixels=512, bg_color=#000000):
                create 'self.pixels' and set it as 'pixels'
                create 'self.bg_color' and set it as 'bg_color'
                create 'self.dict' and set it as 'dict'
                create 'self.color_array' and set it as []
                create 'self.min', 'self.size' to 'min_max_list'
                create 'self.window' is assigned to a new Tk() window
                create a 'Canvas' object('self.window', width as 'self.pixels', height as 'self.pixels', and background as 'self.bg_color') and set it to 'self.canvas'
                use creat_image with the parameter of ('self.pixels'/2, 'self.pixels'/2, image=PhotoImage with a width and height of 'self.pixels', state set as 'normal') on 'self.canvas'
                pack 'self.window'
        
        status_bar function:
        input: an int variable that designeates how many pixels on the screen have been covered
        output: Prints a progress bar to the terminal
                returns nothing
        ============
        def status_bar(self):
            print a status bar by using a formated string with 'self.pixels' and >4.0% to have 4 spaces for the percentage to show
                    add a space character
                    add a formated string that prints a '=' based off of 34 times 'self.pixels' that spans <33 spaces
                    set end to '\r' so that the bat get overwritten to who a in place updating progress bar
                    and redirect all of the output to sys.stderr
        
        min_max_list function:
        input: This function takes no input
        ouput: This function does not print anything to the terminal or tkinter window
                returns 2 lists of float numbers and a float number
        ============
        def min_max_list(self):
            create a 'min' array, with the first element as 'self.dict'['centerx'] - ('self.dict'['axislength']/2.0) and the second as 'self.dict'['centerY'] - ('self.dict'['axislength'] / 2.0)
            create a variable 'max' and set it as 'self.dict'['centerx'] + ('self.dict'['axislength']/2.0)
            create a float variable 'size' and assign the absolute value of ('max' - 'min'[0])/2
            return 'min' list and 'size'
        
        draw_phoenix_fractal function:
        input: This function takes a dictionary object
        output: This function creates a tkinter window and draws the fractal within the window
                returns nothing
        ============
        def draw_phoenix_fractal(self):
            for 'row' in range of 'self.pixels', stop at position 0, and step backwards by -1:
                for 'column' in range of 'self.pixels':
                    calculate the 'X' coordinate by adding 'self.min[0]' to 'column' and then times it by size
                    calculate the 'Y' coordinate by adding 'self.min[1]' to 'row' and then times it by size
                    create a str variable 'color' and call Palette.phoenix_palette[phoenix.count( z as complex(0,0), 'max_iterations' as 'self.dict'['iterations'], c as the complex('X' and 'Y'), and phoenix as complex('self.dict'['fpreal'] and 'self.dict'['pimag'])]
                    append 'color' to 'self.color_array'
                create the variable 'row_color' that will hold all of the pixel colors on one row by joining all the elements in the list of 'self.color_array'
                put 'row_color' in 'self.window' to 0, 'self.pixels' minus 'row'
                update 'self.window'
                create a variable 'pixels_covered' and set it to 'self.pixels' minus 'row' then divided by 'self.pixels' and pass it to 'status_bar()'
            write 'self.window' to a .png with the name of 'self.dict'['name']
        
        draw_mbrot_fractal function:
        input: This function takes a dictionary object
        output: creates a tkinter window and draws the mandelbrot fractal
                returns nothing
        =============
        def draw_mbrot_fractal():
            for 'row' in range of 'self.pixels', stop at position 0, and step backwards by -1:
                for 'column' in range of 'self.pixels':
                    calculate the 'X' coordinate by adding 'self.min'[0] to 'column' and then times it by size
                    calculate the 'Y' coordinate by adding 'self.min'[1] to 'row' and then times it by size
                    create a str variable 'color' and call Palette.mbrot_palette[mbrot.count(c as complex number of 'X' and 'Y', 'max_iterations' as 'self.dict'['iterations'])]
                    append 'color' to 'self.color_array'
                create the variable 'row_color' that will hold all of the pixel colors on one row by joining all the elements in the list of 'self.color_array'
                put 'row_color' in 'self.window' to 0, 'self.pixels' minus 'row'
                update 'self.window'
                create a variable 'pixels_covered' and set it to 'self.pixels' minus 'row' then divided by 'self.pixels' and pass it to 'status_bar()'
            write 'self.window' to a .png with the name of 'self.dict'['name']
        
        mainloop function:
        input: no input
        output: keeps tkinter window open
                returns nothing
        ============
        def mainloop(self):
            call mainloop()
        
        main.py
        from image import Image
        import parser.py
        import sys
        
        if __name__ == '__main__':
            if sys.argv[0] has 'main':
                print an error message 'Please run either mbrot_fractal.py or phoenix_fractal.py'
            if the length of sys.argv is less than 2:
                print an error message "Please provide the name of a fractal as an argument", to sys.stderr
                print another line on how to use the program "Usage: {sys.argv[0]} FRAC_FILE" to sys.stderr
                exit with sys.exit
            create a variable 'start' that holds the current time()
            if sys.argv[0] has 'phoenix_fractal:
                create a 'Image' object img(parser.phoenix_dictionary(sys.argv[1]), 'phoenix')
                print "Rendering {img.dict['name']} fractal" to sys.stderr
                call 'img'.draw_phoenix_fractal()
            elif sys.argv[0] has 'mbrot_fractal':
                create a 'Image' object img(parser.mbrot_dictionary(sys.argv[1]))
                print "Rendering {img.dict['name']} fractal" to sys.stderr
                call 'img'.draw_mbrot_fractal
            call 'img'.mainloop() to keep the window open
            print "\nDone in {time.time() - before:.3f} seconds!" to sys.stderr
            print "Saved image to file {img.dict['name']}.png" to sys.stderr
            print "Close the image window to exit the program" to sys.stderr
        ```
*   [X] Explain what happens in the face of good and bad input.
    *   In the face of good input:
        *   The program will display the following in the terminal:
        *   ```bash
            Rendering {name of fractal} fractal
            [100% =================================]
            Done in 0.942 seconds!
            Saved image to file {name of fractal}.png
            Close the image window to exit the program
            ```
        *   The tkinter window will open and draw the correct fractal image as is stored in `data/assets`
    *   In the face of bad output:
        *   The program will display an error message if there is no file from `data/` is provided:
        *   ```bash
            Please provide the name of a fractal as an argument
            Usage: src/phoenix_fractal.py FRAC_FILE
            ```
        *   The program will raise an error if the file provided does not exist:
        *   ```bash
            Traceback (most recent call last):
              File "C:\Users\Macro\cs1440-proj4\src\phoenix_fractal.py", line 459, in <module>
                _,c=p(sys.argv[1])
                    ~^^^^^^^^^^^^^
              File "C:\Users\Macro\cs1440-proj4\src\phoenix_fractal.py", line 335, in p
                F = open(f)  # open the file
            FileNotFoundError: [Errno 2] No such file or directory: 'FILENAME'
            ```
        *   If a fractal file from `src` is not compatible with the `data/` file provided, then an error message will be written about compatibility and still make the fractal image:
        *   ```bash
            $ python src/phoenix_fractal.py data/mandelbrot.frac
            Warning! incompatible fractal type detected: 'mandelbrot'
            Rendering mandelbrot fractal
            [100% =================================]
            Done in 4.191 seconds!
            Saved image to file mandelbrot.png
            Close the image window to exit the program
            ```
        *   If there is a bad value in a `.frac` file passed to the terminal, an error will be raised, such as this `ValueError`
        *   ```bash
            ValueError: Bad numeric value at line #10 of src/tests/m/bad-float-value.frac: 'twopointseventeen'
            ```
*   [X] **Tag** the last commit in this phase `4.0-designed` and push it to GitLab.
    *   *Grace Points: if this tag is pushed before class on the Monday before the due date, you will receive up to 5 points back*


Phase 2: Implementation (tag name `4.0-implemented`)
----------------------------------------------------
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [X] Working code in the `src/` folder.
*   [X] Note any relevant and interesting events that happened while you wrote the code.
    *   As I wrote the designs out into code, I realized I could separate the code into more methods. The `dict_creator` method in `parser.py` is one of those
    *   Going step by step to create the status bar into a formatted string on one line in the method `pixelsWrittenSoFar` in `mbrot_fractal.py` helped alot to make the `status_bar` method in `image.py` to work
    *   `.pack()` in the `tkinter` module seems like its needed to be called constantly, but in reality its only needed to be called once, which cleans up a lot of code
    *   I moved all the printed text to the `Image` class in `image.py`, it made it possible to have next to none `print()` statements in `mbrot_fractal.py` and `phoenix_fractal`
    *   Using `z**2` in the count functions slows them down by 3-5 seconds compared to `(z*z)`, which is only about 1 second slower than the original factored files.
*   [X] **Tag** the last commit in this phase `4.0-implemented` and push it to GitLab.


Phase 3: Testing and Debugging (tag name `4.0-tested`)
------------------------------------------------------
*(30% of your effort)*

Your grade depends on how your program performs when run from the command line.  We don't use PyCharm to grade, so ensure your program runs correctly from the shell.

Deliver:

*   [X] A set of test cases that you have personally run on your computer.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.
        *   Run `src/mbrot_fractal.py` with `data/m-spiral0.frac` - it will output the following:
            *   ```bash
            $ python src/mbrot_fractal.py data/m-elephants.frac
            Rendering m-elephants fractal
            [100% =================================]
            Done in 2.319 seconds!
            Saved image to file m-elephants.png
            Close the image window to exit the program
                ```
            *   ![](./assests/m-elephants.png "Elephants")
            *   The seconds should be around 2.300 - 2.800
        *   Run `src/mbrot_fractal.py` with `data/phoenix.frac` - it will output a warning message in the following:
            *   ```bash
                Warning! incompatible fractal type detected: phoenix
                Rendering phoenix fractal
                [100% ================================ ]
                Done in 0.765 seconds!
                Saved image to file phoenix.png
                Close the image window to exit the program
                ``` 
            *   If a non-compatible file from `data/` is used with the incorrect fractal file, then the warning message will appear
        *   Run `src/phoenix_fractal.py` with `data/phoenix.frac` - it will output the following:
            *   ```bash
                Rendering phoenix fractal
                [100% ================================ ]
                Done in 0.822 seconds!
                Saved image to file phoenix.png
                Close the image window to exit the program
                ```
            *   ![](./assests/phoenix.png "Phoenix")
            *   The seconds should be around 0.760 - 1.000
        *   Run `src/phoenix_fractal.py` with `data/mandelbrot.frac` - it will output a warning message in the following:
            *   ```bash
                Warning! incompatible fractal type detected: mandelbrot
                Rendering mandelbrot fractal
                [100% ================================ ]
                Done in 1.811 seconds!
                Saved image to file mandelbrot.png
                Close the image window to exit the program
                ``` 
            *   If a non-compatible file from `data/` is used with the incorrect fractal file, then the warning message will appear
        *   Run `src/phoenix_fractal.py` without any other arguments - it will output a message on how to use the fractal file:
            *   ```bash
                Please provide the name of a fractal as an argument
                Usage: src/phoenix_fractal.py FRAC_FILE
                ``` 
        *   Run `src/mbrot_fractal.py` without any other arguments - it will output a message on how to use the fractal file:
            *   ```bash
                Please provide the name of a fractal as an argument
                Usage: src/mbrot_fractal.py FRAC_FILE
                ``` 
        *   Run `src/main.py` with `data/mandelbrot.frac` - it will output a message on how to use the fractal file:
            *   ```bash
                Please run either mbrot_fractal.py or phoenix_fractal.py
                ``` 
        *   Run `src/phoenix_fractal.py` with `data/IDONTEXIST` - it will crash and output the following error message:
            *   ```bash
                Traceback (most recent call last):
                  File "C:\Users\Macro\cs1440-proj4\src\phoenix_fractal.py", line 44, in <module>
                    phoenix_dict = parser.phoenix_dictionary(sys.argv[1])
                  File "C:\Users\Macro\cs1440-proj4\src\parser.py", line 49, in phoenix_dictionary
                    phoenix_dict = dict_creator(filename, 'phoenix')
                  File "C:\Users\Macro\cs1440-proj4\src\parser.py", line 11, in dict_creator
                    f = open(filename)
                FileNotFoundError: [Errno 2] No such file or directory: 'data/IDONTEXIST'
                ``` 
        *   Run `src/mbrot_fractal.py` with `data/IDONTEXIST` - it will crash and output the following error message:
            *   ```bash
                Traceback (most recent call last):
                  File "C:\Users\Macro\cs1440-proj4\src\mbrot_fractal.py", line 40, in <module>
                    mbrot_dict = parser.mbrot_dictionary(sys.argv[1])
                  File "C:\Users\Macro\cs1440-proj4\src\parser.py", line 59, in mbrot_dictionary
                    mbrot_dict = dict_creator(filename, 'mandelbrot')
                  File "C:\Users\Macro\cs1440-proj4\src\parser.py", line 11, in dict_creator
                    f = open(filename)
                FileNotFoundError: [Errno 2] No such file or directory: 'data/IDONTEXIST'
                ```
        *   Run the tests in `src/run_tests.py`
            *   `test_min_max` tests to make sure that the calculations returned line up with the expected numbers that should be returned by the function
            *   `test_phoenix_count` tests whether the phoenix `count` function returns a number greater than `2` or less than `2` and that it creates the correct `x` and `y` values from the numbers in `test_dict`
            *   `test_mbrot_count` tests whether the phoenix `count` function returns a number greater than `2` or less than `2` and that it creates the correct `x` and `y` values from the numbers in `test_dict`
            *   `test_phoenix_dict` tests if a phoenix dictionary is correctly created from the `dictionary` function and that it catches errors in the provided `data/` file
            *   `test_mbrot_dict` tests if a mandelbrot dictionary is correctly created from the `dictionary` function and that it catches errors in the provided `data/` file
            *   `test_dict_creater` tests if the `dict` object is created correctly from the provided `data/` file
            *   `test_phoenix_color` tests if `get_phoenix_color` returns the correct color from the provided index number
            *   `test_mbrot_color` tests if `get_mbrot_color` returns the correct color from the provided index number
            *   `test_tkinter_window` verifies if a window and image objects are created, the width of the image is correct, and that there is a start time provided
            *   `test_status_bar` tests the status of the status bar when a number is passed to the `status_bar` function
    *   For any bugs discovered, describe their cause and remedy.
        *   In `palettes.py`, the `phoenix_palette` had the hexadecimal `FFFFFF` without `#`, so by using `#FFFFFF` the program could iterate through the palette
        *   In `image.py`, the method `status_bar` was not printing a correct status bar with the progress bar and percentage.
            *   I was dividing `self.pixels` by `row`, but I need to minus `row` from `self.pixels`
            *   I worked on putting all the code for `pixelsWrittenSoFar` on one line, then converted if from a list being made into a formatted string being printed
        *   Total time taken to draw the fractal was displaying `0.000s`
            *   made a method `time_to_draw` in the class `Image` to print the time
            *   When the `Image` object is created, make a `self.start_time` to keep track of the start of when the fractal began to be drawn
        *   The `count` method was not outputting the correct color index that would get the correct color from `phoenix_palette`
            *   I tried multiplying `(z**2 + c) * (phoenix * z_prev)`, but I need to add them, `(z**2 + c) + (phoenix * z_prev)`
            *   As well, I needed to pass in the julia consent for `c`, not a complex number made from `x` and `y`
        *   For the test cases in the method `test_phoenix_dict` and `test_mbrot_dict`, they were not raising a `RunTime` exception correctly
            *   I moved the dictionary that is created as a global variable into the function `dict_creator()` in the module `parser.py`, allowing the dictionary to be cleared from memory and not hold the previous dictionary keys and values
        *   I had an issue where `src/mbrot_fractal.frac` with the file `data/mandelbrot.frac` was not printing the same fractal image as it did before refactoring it.
            *   After about 4 hours of pain I found out that I need to hard code the max_iteration count and not use the iteration count from the `.frac` file. It only took me 4 hours and lots of pain
            *   I put the length of the respective palettes in the `count` functions as the `max_iterations` parameter, so that it doesn't rely on the `.frac` file's `iteration` number and the fractal appears the same as it did before refactoring
*   [X] **Tag** the last commit in this phase `4.0-tested` and push it to GitLab.


Phase 4: Deployment (tag name `4.0-deployed`)
---------------------------------------------
*(5% of your effort)*

Deliver:

*   [X] **Tag** the last commit in this phase `4.0-deployed` and push it to GitLab.
*   [X] Your repository is pushed to GitLab.
*   [X] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Look for all of the tags in the **Tags** tab.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [X] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


Phase 5: Maintenance
--------------------

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [X] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   I think the functions `dict_creater` and `draw_fractal` are the hardest to understand and can be written better
        *   Are there parts of your program which you aren't quite sure how/why they work?
            *   The `create_window` and other tkinter functions/items I still don't understand fully
            *   I still am not entirely clear about the equations used to find different coordinate values in `draw_fractal` and `min_max`
        *   If a bug is reported in a few months, how long would it take you to find the cause?
            *   I think it would take couple hours, but not much more than that. Everything has been organized and simplified to narrow down any problem down to its main function/helper functions  
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
            *   Yes, I made sure to use clear language and precise examples to explain problems and different coding choice made during the refactoring process 
        *   ...yourself in six month's time?
            *   Yes, I made the documentation in a way so that others and I could follow my thought process and see where changes come from. 
    *   How easy will it be to add a new feature to this program in a year?
        *   I think it would be easy due to the fact that I tried making all the functions be usable with the change in only the fractal name provided. 
        *   Adding logic that detects and changes different dictionary items/program behavior based on fractal names would probably the hardest part of adding a new feature 
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
            *   The program will run faster due to the computers capacity to run the code faster
        *   ...the operating system?
            *   The program will not be affected by a change in OS, it should work the same on all them 
        *   ...to the next version of Python?
            *   If dictionaries are changed at some point in the future, then it would change in the next version. As well, if the functions `.startswith` and `.replace` are changed, then it would affect the programs performace and output
*   [X] Make one final commit and push your **completed** Software Development Plan to GitLab. 
*   [X] Respond to the **Project Reflection Survey** on Canvas.
